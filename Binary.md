### 前言

本篇用于厘清二进制的本质。提示，建议使用 [Typora](https://typora.io/) 打开文件，否则公式可能无法进行正确显示。

### 数字只是数量一种标识

想要表达数量，我们可能会使用十进制阿拉伯数字“2”，也可能使用英文“two”，还可能使用中文“二”或“贰”。但无论是什么类型的表达，数量只是一种概念。

传统学科数学中，我们习惯于使用阿拉伯数字作为数量的标识。

### 十进制

十进制中规定了 0~9 之间的阿拉伯数字作为组成十进制的标准数字，其遵循“逢十进一”的规则。

任意的十进制数字 z，都可以使用以下的数学公式进行表达：
$$
z=x*10^m+x*10^{m-1}+...+x*10^{-1}+x*10^0+x*10^1+...+x*10^{n-1}+x*10^n
$$

例如，数字 7348 写成公式如下：
$$
7348=7*10^3+3*10^2+4*10^1+8*10^0
$$

例如，小数 32.7634 写成公式如下：
$$
32.7634=3*10^1+2*10^0+7*10^{-1}+6*10^{-2}+3*10^{-3}+4*10^{-4}
$$

### 进制是什么

进制根据不同的进制规则可以被区分为许多种，常用的进制有二进制、八进制、十进制和十六进制。例如，十进制数字 11 使用不同的进制进行书写，其形式是不一样的：

- 使用二进制描述十进制数 11 书写为“1011”；
- 使用八进制描述十进制数 11 书写为“13”；
- 使用十六进制描述十进制数 11 书写为“b”。

类似于十进制数可以分解为十次幂数之和的公式一样，对应进制的数字也可以分解为对应幂次数之和的公式。

### 二进制转十进制整数

- 我们已经知道了这些描述数量的阿拉伯数字组合，不过是在指定进制下以，该进制数为底的幂次相加描述指定数量的系数的集合，而数学基于十进制的，我们可以通过幂、算数运算符等将一个进制对数量的描述转换成为数学上对这个描述的公式表达；
- 二进制 1011 可以被表达为：（使用等号和加号其实是不妥当的表达，本质上等号和加号是十进制运算符）

$$
1011=1*2^3+0*2^2+1*2^1+1*2^0
$$

- 数学是基于十进制的，所有的幂运算、算数运算都是基于十进制被规定的，通过加法的运算，我们可以得到对应的十进制描述：

$$
1*2^3+0*2^2+1*2^1+1*2^0=1*2^3*10^0+0*2^2*10^0+1*2^1*10^0+1*2^0*10^0
$$

$$
1*2^3*10^0+0*2^2*10^0+1*2^1*10^0+1*2^0*10^0=1*10^1+1*10^0
$$

$$
1*10^1+1*10^0=11
$$

- 所有其他进制的数，可以使用加法转换为十进制数。

### 十进制整数转二进制原码

- 十进制数转二进制数，假设十进制数为 13 ：

$$
13=13*2^0
$$

- 系数大于 2 ，将系数进行拆分，可以看出十进制数除以数字二得到的第一个余数即为 2 的零次幂的系数：

$$
13*2^0=(6*2 + 1)*2^0
$$

- 进一步得到：

$$
6*2^1+1*2^0
$$

- 系数仍然大于 2 ，继续拆分，第二次（减去余数后）除以数字二，得到的第二个余数，即为 2 的一次幂的系数：

$$
(3*2 + 0)*2^1+1*2^0
$$

- 进一步得到：

$$
3*2^2 + 0*2^1+1*2^0
$$

- 系数依旧大于 2 ，继续拆分：

$$
(1*2+1)*2^2+0*2^1+1*2^0
$$

- 得到最终结果为：

$$
1*2^3+1*2^2+0*2^1+1*2^0
$$

- 即二进制数 1101 ：（使用等号和加号其实是不妥当的表达，本质上等号和加号是十进制运算符）

$$
1*2^3+1*2^2+0*2^1+1*2^0=1101
$$

### 二进制小数转十进制小数

- 二进制的小数也是使用小数点来区分零次幂与负一次幂的，二进制数也是描述数量的，根据二进制数位上的值与对应的进制幂次进行相乘，是不会影响描述数量多少的，之后使用加法运算，将会把描述数量的值转换为十进制的数字。

- 假设有二进制数 11.11 （也就是十进制的 3.75 ），则可获得它的科学计数法表达：（使用加号其实是不妥当的表达，本质上加号是十进制运算符）

$$
1*2^1+1*2^0+1*2^{-1}+1*2^{-2}
$$

- 转换为十进制，我们需要 10 次幂的科学技术法表达：

$$
2*10^0+1*10^0+5*10^{-1}+25*10^{-2}
$$

- 进一步将得到：

$$
3*10^0+5*10^{-1}+(2 * 10 + 5) * 10^{-2}
$$

- 简化得到：

$$
3*10^0+7*10^{-1}+5*10^{-2}
$$

- 此时没有系数大于等于十，完成转换，此时的科学计数法表示的数字写成十进制即 3.75 。

### 十进制小数转二进制小数

- 将十进制转为二进制，目的是要找到在该数中包含多少种 2 的 n 次幂，其中2的n次幂的系数只能为 1 或 0 ，采用科学计数的方式，对十进制的数字进行分解，例如数字 17.25 ，可以获得以下表达式：

$$
17.25=1*10^1+7*10^0+2*10^{-1}+5*10^{-2}
$$

- 接下来我们同样在每一位上乘以 2 的零次幂：

$$
17.25*2^0
$$

- 继续推导：

$$
34.5*2^{-1}=69*2^{-2}
$$

- 继续推导：

$$
(34*2 + 1)*2^{-2}=34*2^{-1}+1*2^{-2}=(17*2)*2^{-1} + 1*2^{-2}...
$$

- 最终得到：

$$
1*2^4+0*2^3+0*2^2+0*2^1+0*2^0+0*2^{-1}+1*2^{-2}
$$

- 即二进制数 10000.01 。

### 转换规律

- 不难发现，在十进制小数转为二进制小数的时候，只有当幂次大于等于 0 的时候，会累加得到十进制的整数部分，而只有但幂次小于 0 的时候，会累加得到十进制的小数部分。由于系数只能为 0 或 1 ，小数部分的范围只能是 [0, 1) 。因此十进制小数转二进制小数是可以进行整数位与小数位的单独计算。

- 下面只演示十进制小数部分转为二进制的过程，假设我们有十进制数 0.35 ，我们的目的是找到科学计数下2的小于零次幂的表示方式，有以下表达式：

$$
0.35*2^0
$$

- 二进制系数只能为 1 或 0 ， 0.35 为 0 但也不足 1 ，我们进行推导：

$$
(0.35*2)*2^{-1}=0.7*2^{-1}
$$

-  0.7 依旧不为 0 也不足 1 ，继续推导：

$$
0*2^{-1}+(0.7*2) *2^{-2}=0*2^{-1}+1.4*2^{-2}=0*2^{-1}+1*2^{-2}+0.4*2^{-2}
$$

- 接下来是 0.4 ，不为 0 也不足 1 ：

$$
0*2^{-1}+1*2^{-2}+0.8*2^{-3}=0*2^{-1}+1*2^{-2}+0*2^{-3}+1.6*2^{-4}
$$

- 继续推导：

$$
0*2^{-1}+1*2^{-2}+0*2^{-3}+1*2^{-4}+1*2^{-5}+0.4*2^{-6}
$$

- 继续推导：

$$
0*2^{-1}+1*2^{-2}+0*2^{-3}+1*2^{-4}+1*2^{-5}+0*2^{-6}+0.8*2^{-7}
$$

- 此时我们又得到了 0.8 ，也就是后面的推导都会得到同样的结果，二进制中的0.35是一个循环小数，使用二进制表示为： 0.010110011001100110 ...







- 提示，在使用多态创建对象引用的时候，应该注意以下方面：

1. 使用该引用不可调用子类特有的方法，如果需要使用子类特有的方法，需要进行向下转型，转型前可以使用关键字 instanceof 进行判断；
2. 关于向下转型，如果使用new关键字创建的类C具有子类A与父类B，那么可以对C进行向上转型为B，这是被允许的；但是如果你理所当然认为可以对C进行向下转型为A，这是不被允许的，将出现运行期异常；
3. 如果调用的方法子类不具有，就会向上寻找，直到找到为止，否则出现编译期异常；
4. 如果调用的方法是当前对象的父类的方法，父类的该方法中调用的任何方法，都将继续自下而上寻找，假如在子类中找到了该方法，将使用该方法；

5. 如果调用的方法是当前对象的父类的方法，父类的该方法中调用的任何方法中如需传入参数，则该参数必定是父类中的成员变量或是当前父类调用此方法的方法中的局部变量，而或是常量。

- 提示，在使用static关键字的时候，应该注意以下方面：
  1.  static 关键字只能用于成员变量和成员方法；
  2.  static 关键字修饰的成员方法，只能使用同样被 static 修饰的成员变量；没有被 static 关键字修饰的成员方法，也可以使用被 static 修饰的成员变量；
  3.  static 修饰的成员变量和成员方法只存在唯一的一份，因此在背 static 关键字修饰的成员变量和成员方法前不可使用 this 关键字， this 关键字表示的是当前的对象引用。

- 提示，在使用 final 关键字的时候，应该注意以下方面：
  1.  final 关键字修饰的如果是一个基本数据类型，则表示的是这个基本数据类型的值不可变；如果修饰的是一个引用数据类型，则表示这个引用数据类型的地址值不可变；
  2.  final 关键字修饰普通类，则该类不可被继承；
  3.  final 关键字修饰成员方法，则该成员方法不可被覆写；
  4.  final 关键字修饰的成员变量，必须要进行初始化，可以直接进行赋值，也可以在构造器中对 final 修饰的成员变量进行初始化操作，需要注意的是，需要保证在所有重载形式的构造器方法中，都会对该成员变量进行初始化操作：
     1. 假如你拥有一个普通类，类中有一个 final 修饰的包装类 Integer 对象引用，你可以选择使用赋值的形式对其进行初始化，也可以在当前类的构造器方法中对其进行初始化，如果不进行任何初始化，则会出现编译期异常；
     2. 对于基本数据的包装类来说，应该是比较特殊的存在，接下里举例使用final修饰一个普通的类，可以是数组、列表、集、映射或自定义的类，这里假如是自定义类 Person ， Person 中包含不以 final 修饰的三个成员变量 name 、 age 、 gender ，对于引用数据类型来说，使用final修饰那么不可变的只是地址值，纵使初始化为 null ，也可以使用相应的 Setter 方法对其中的 name 、 age 、 gender 进行更改；
     3. 在上一点的基础上，可能会出现疑问，那么既然是地址值不可变，为什么包装类Integer后续无法更改值？ Integer 中拥有一个使用 final 修饰的用于存储 int 类型的成员变量 value ，而 Java 中虽然可以直接使用运算符 = 将基本数据类型 int 自动装箱为包装类 Integer ，但实际上最后也会调用 Integer 类的构造器方法，对 value 进行初始化操作；那么自然在“二次赋值”时，程序会再次调用 Integer 构造器方法尝试对 final 修饰的基本数据类型int类型的 value 进行初始化操作，然而 value 已经被初始化并不可更改了，程序自然出现编译期异常。

- 当执行语句 Integer num = 18; 时， Java 将会自动完成装箱过程， Java 会自动调用 valueOf(int i) 方法，对 int 类型的 18 进行装箱，因此我们需要知道方法 valueOf(int i) ，查看源码：

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

```java
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high >= 127;
    }

    private IntegerCache() {}
}
```

-  IntegerCache 是一个私有静态内部类，成员变量 low 的值固定为 -128 。其中的静态代码块的作用，主要是为了确定成员变量 high 的值，默认为 127 。同时静态代码块将为静态数组 cache 设置初始容量 capacity 及在其中填充 [-128, 127] 共 256 个 Integer 对象。
- 我们把上面代码综合一下，可以得到以下推论代码：

```java
static final Integer[] cache; // 此数组包含-128~127的Integer对象，可以理解为缓存池，这256对象是可复用的。

public static Integer valueOf(int i) {
    if (i >= -128 && i <= 127)
        return cache[i + 128];
    return new Integer(i);
}
```

- 可以明确的一点是，使用 valueOf(int i) 获取 Integer 对象的时候，最后调用的都是其中的有参构造 Integer(int i)，最终将为 final 成员变量 value 进行初始化操作，这解释了 final 修饰的包装类 Integer 为什么看似是值和地址都不可变的问题，其中的“值不可变”只是其中用于“保存信息”的成员变量 value 被 final 修饰了并已初始化导致了其“不可改变”。
- 同时我们可以轻易推导出，值不可变的类型永远只有被 final 修饰的基本数据类型。即如果一个包装类的某个成员变量是不可变的，那么这个成员变量类型自身的类型或其底层用于储存数据的类型一定是被 final 修饰的基本数据类型。
- 其次，对于 -128 ~ 127 的 int 类型来说，自动装箱为 Integer 的时候，会直接从 cache 数组中取用 Integer 对象，不会再使用 new 关键字创建对象了。在使用 == 比较该范围内的 Integer 对象的时候，得到的结果将是 true ，而不是 false 。
- 扩展知识，包装类 Byte 、 Short 、 Long 中也使用这样的缓存池。


$$
\sum_{k=1}^N k^2
$$

